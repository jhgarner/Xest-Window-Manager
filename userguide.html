<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Xest Window Manager - User guide</title>
        <link rel="stylesheet" href="./css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo" style>
                <a href="./"><!--<img src="/images/xestreordered.svg" style="margin: 10px; height: 10em;" />!--></a>
                <!-- <a href="/">Xest Window Manager</a> -->
            </div>
            <nav>
                <a href="./">Home</a>
                <a href="https://github.com/jhgarner/Xest-Window-Manager">Github</a>
                <a href="./userguide.html">User Guide</a>
            </nav>
        </header>

        <main role="main">
            <h1 id="post-install">Post Install</h1>
<p>Xest will crash if it can’t find a config file in your home directory. If you installed the Arch package, you should be able to copy the contents of the “/etc/xest/config/ folder into”~/.config/xest/config/“. Once you do that, you will need to edit the config files.”config.dhall" is kind of messy right now, but it should have most of what you need. Just make sure to change any hard-coded strings for your system. Most likely you’ll need to change the terminal from “kitty/termite” to something else. You also probably need to change the startup file and font locations. The “startup.sh” will also need some changes. Add whatever you want to run on boot and remove the things that you don’t have. Use “&amp;” to make sure it doesn’t get hung up on any lines that spawn long running commands.</p>
<h1 id="using-xest">Using Xest</h1>
<p>The following key bindings assumes you’re using the default config.dhall (after performing the post install instructions).</p>
<h2 id="modes-and-keys">Modes and Keys</h2>
<p>Once you’ve launched Xest, you should see your desktop wallpaper and not much else. Begin by pressing the Super/Windows key. A pink border should have appeared around your desktop. This border signifies that you are in normal mode. The color and position of the border tell you where you are in Xest’s tree. You can also look at the text on the border to get an idea for where you are. The “@” sign tells you where the monitor is and the “*” tells you where the input controller is. Those will be explained more below.</p>
<p>Pressing “t” should launch your terminal while “d” should launch your launcher.</p>
<p>At some point, you probably want to leave normal mode. You can do that using the escape key. Pressing 3 keys (windows, d, escape) every time you want to launch a program seems kind of long. Although this mode based system has it’s advantages on longer commands, it tends to be less efficient when you just want to perform one action.</p>
<p>Thankfully, Xest has a solution. You can hold down any key that changes your mode to temporarily switch into it. As soon as you release that key, you go back to the mode you were in before. How does Xest identify between temporarily entering a mode and permanently entering one? If you press another bound key while holding down the one that changed your mode, Xest will assume you want it to be temporary. If you let go of the mode key before pressing another, Xest assumes you want to remain in the new mode.</p>
<p>Basically, this is an extremely long winded way to say you can press “Super+d” like you would in i3 to launch rofi/dmenu or “Super+t” to launch the terminal. Any key press in Xest supports temporary and permanent modes.</p>
<p>One of the cool implications of this is the NormalS mode in the default config. In Xest, binding the “I” key is the exact same as binding the “i” key. This might seem like a problem, until you realize that Shift is just another key that can be bound. The NormalS mode is triggered when you press the Shift key while in Normal mode. Because of how temporary modes work, this essentially emulates being able to bind both “I” and “i”.</p>
<p>If NormalS is just a mode, what happens if I press and release the Shift key without hitting anything else? In that case, you enter NormalS mode permanently and can hit a string of capital letters with ease. You can move back to Normal mode by pressing escape. To get back into Insert mode, hit escape again. None of this is hard-coded into Xest. You can find all of this logic in the config.dhall file.</p>
<p>Keys in Xest can be bound to things called actions. This will be covered more in the configuring Xest section.</p>
<h2 id="tilers">Tilers</h2>
<p>As mentioned elsewhere, Xest represents windows as a tree. This means that Xest has some kind of root element in the tree and a bunch of nodes coming off of it.</p>
<p>Nodes in Xest are called Tilers. A Tiler is simply something which can contain 0 or more children and might hold additional metadata. After most actions, Xest prunes the tree and removes the empty Tilers. You can associate keybindings with inserting Tilers into the tree.</p>
<p>If you’re every confused about what the tree looks like, just enter Normal mode. On the top most border, a textual representation of the tree is provided. The text shows you the path from the root of the tree all the way to the currently focused window.</p>
<p>Here are some of the Tilers:</p>
<h3 id="wrap">Wrap</h3>
<p>A Wrap Tiler represents a leaf on the tree. It simple wraps a normal window and has no children.</p>
<h3 id="many">Many</h3>
<p>Many is a complicated Tiler and holds a lot of power. It’s called Many because it can hold many children. By default, each child is tiled horizontally like in i3. If you want to have 1 background Tiler with the rest floating on top, you can tell Many to change to a “floating” style. If you want a 2 column approach like Xmonad uses, you can switch to the “twoCols” style. You can also rotate everything using the “rotate” modifier. This turns the “horizontally” style into a vertical one and the “twoCols” style into something that might be called “twoRows”. Finally, you can set the “full” modifier to make the currently focused child take up all of the space.</p>
<p>How do you create grids of windows? The children to any Tiler are other Tilers. If you nest Many multiple times, you can create arbitrarily complex layouts. If you nest Many with the “full” modifier set, you can get something like nested workspaces.</p>
<p>On the border, a Many Tiler is represented as “|&lt;modifier&gt;-&lt;style&gt;-&lt;#children&gt;-&lt;focusedChild&gt;|”.</p>
<h3 id="monitor">Monitor</h3>
<p>This Tiler tells Xest when to start rendering on a given screen. By default, the Monitor is the root of the screen. You can zoom it inwards to minimize entire branches of the tree. This is another way to create a form of workspaces.</p>
<p>On the border, a Monitor is represented as “@”.</p>
<h3 id="input-controller">Input Controller</h3>
<p>This Tiler let’s you control where you want Actions to be applied and where new windows should be placed. When a new window is created, it is made a child of whatever comes immediately after the Input Controller. Likewise, if you perform some action, it is applied to whatever is the Input Controller’s immediate child. Like the Monitor, you can move the Input Controller around the screen.</p>
<p>On the border, an Input Controller is represented as “*”.</p>
<h2 id="zooming">Zooming</h2>
<p>Take a moment to imagine your typical Gnome/Windows workflow assuming you’re making use of virtual desktops. In those options, you have some kind of task or overview mode to help you see the bigger picture. For example, in Gnome it happens when you press the windows key. In Windows it happens when you press the virtual desktop button on the taskbar. When you enter this kind of view, it’s almost like you’re “zooming out” from the desktop you had been working in. Instead of looking at one desktop, you can now see several. Likewise, you can usually click on one of the desktops to zoom back in on whatever you were working on.</p>
<p>This zooming concept is taken to the extreme in Xest as it’s your primary way of moving around. By making zooming explicit, we can get features like workspaces and window maximization in one “simple” idea. In no time, you’ll find your efficiency zooming past its former self :)</p>
<p>Zooming can be applied to either the Input Controller or the Monitor. Check out the list of actions when configuring Xest for more details.</p>
<h2 id="poppingpushing">Popping/Pushing</h2>
<p>Xest keeps a stack of popped tilers in it’s memory. When you pop a window, it gets removed from the tree. You can add it back into the tree using the Push action.</p>
<p>Unlike other Window Managers, Xest doesn’t have a dedicated Action for moving windows to other desktops. Instead, you have to use popping and pushing to accomplish that.</p>
<p>One of the benefits to this is Xest can yank entire sections of your tree at once.</p>
<h1 id="configuring-xest">Configuring Xest</h1>
<h2 id="dhall">Dhall</h2>
<p>Xest is configured using a language called Dhall. I would highly recommend reading through their website and looking at the interactive examples.</p>
<p>In essence, Dhall is a functional configuration language. It has powerful features like first class functions and polymorphism. Dhall also prides itself in being a total language; you can be certain that a Dhall program will not infinitely loop or run any IO beyond importing other Dhall files.</p>
<p>That import feature is one of Dhall’s greatest strengths and makes it really easy to share your configs. Dhall supports loading config files from local and online sources. After verifying that the configs you want are indeed good, you can run Dhall freeze to cache them locally. This provides an alternative to copying and pasting configs from Github.</p>
<h2 id="config-sections">Config Sections</h2>
<p>The Dhall config is a dictionary with a few sections.</p>
<h3 id="startupscript">StartupScript</h3>
<p>A string containing a script to run in your shell. This is useful for starting things like Compton, Feh, Polybar, etc.</p>
<h3 id="initialmode">InitialMode</h3>
<p>A single mode which will be used once you start up Xest.</p>
<h3 id="fontlocation">fontLocation</h3>
<p>The location of the font to use on the border. This is probably something in “/usr/share/fonts/…”.</p>
<h3 id="keybindings">KeyBindings</h3>
<p>A list of key bindings. See the example config file for more info on the format. The weirdest field is the exitActions one. This field contains a list of actions that will be performed when the key is released assuming it didn’t trigger a permanent mode change.</p>
<p>You can get most key names using the “xev” tool from your distro.</p>
<h2 id="actions">Actions</h2>
<p>Actions are performed when you press a key binding or change modes. You can perform multiple actions at any time. If an action is invalid, it should do nothing instead of crashing Xest.</p>
<h3 id="insert">Insert</h3>
<p>Adds a Many Tiler right after the Input Controller. Whatever used to be the Input Controller’s child will become the child of the Many Tiler.</p>
<h3 id="runcommand-s-text">RunCommand (s: Text)</h3>
<p>Runs a command using your shell.</p>
<h3 id="changemodeto-m-mode">ChangeModeTo (m: Mode)</h3>
<p>Changes the current mode. For example, I usually map the Windows key to Normal mode and the escape key to Insert mode.</p>
<h3 id="showwindow-w-text">ShowWindow (w: Text)</h3>
<p>Shows a given window given it’s class name. For example, this can be used to hide or show a taskbar. You should probably avoid using this on windows managed by Xest.</p>
<h3 id="hidewindow-w-text">HideWindow (w: Text)</h3>
<p>The opposite of the above Action.</p>
<h3 id="zoomininputzoominmonitor">ZoomInInput/ZoomInMonitor</h3>
<p>Zooms the input/monitor away from the root towards whatever window is focused.</p>
<h3 id="zoomoutinputzoomoutmonitor">ZoomOutInput/ZoomOutMonitor</h3>
<p>The inverse of the above Action.</p>
<h3 id="poptiler">PopTiler</h3>
<p>Yanks a Tiler onto the stack.</p>
<h3 id="pushtiler">PushTiler</h3>
<p>The inverse of the above Action.</p>
<h3 id="makeempty">MakeEmpty</h3>
<p>If a Many Tiler is the direct child of the Input Controller, this will create a new child for that Many Tiler and will place the Input Controller inside of it. If the Many Tiler has the full modifier set, this could be seen as creating a new workspace.</p>
<h3 id="movetofront">MoveToFront</h3>
<p>If a Many Tiler is the direct child of the Input Controller, this will move whatever the currently focused child is to the “front” of the Tiler. What the front means depends on the style and modifiers of the Tiler.</p>
<h3 id="changetohorizontal">ChangeToHorizontal</h3>
<p>If a Many Tiler is the direct child of the Input Controller, this will change to the horizontal style.</p>
<h3 id="changetofloating">ChangeToFloating</h3>
<p>If a Many Tiler is the direct child of the Input Controller, this will change to the floating style.</p>
<h3 id="changetotwocols">ChangeToTwoCols</h3>
<p>If a Many Tiler is the direct child of the Input Controller, this will change to the twoCols style.</p>
<h3 id="setrotate">setRotate</h3>
<p>If a Many Tiler is the direct child of the Input Controller, this will change to the rotate modifier.</p>
<h3 id="setfull">setFull</h3>
<p>If a Many Tiler is the direct child of the Input Controller, this will change to the full screen modifier.</p>
<h3 id="setnomod">setNoMod</h3>
<p>If a Many Tiler is the direct child of the Input Controller, this will remove whatever the current modifier is.</p>
<h3 id="changenamed-n-text">ChangeNamed (n: Text)</h3>
<p>Change to a different child. Currently, the only valid names are numbers.</p>
<p>Move (d: Direction) ^^^^^^^^^^^^^^</p>
<p>Changes children either forwards or backwards depending on the value passed to it.</p>
<h3 id="killactive">KillActive</h3>
<p>Kills the currently focused window.</p>
<h3 id="exitnow">ExitNow</h3>
<p>Exits from Xest without trying to kill anything nicely first. If you trigger this on accident, you will likely lose work.</p>
<h3 id="togglelogging">ToggleLogging</h3>
<p>Each call to this action toggles whether logging happens in the /tmp/xest.log file. By default, it is off. Each time you turn it on, the file is overwritten.</p>
<h3 id="zoommonitortoinput">ZoomMonitorToInput</h3>
<p>Moves the Monitor so that it is right behind the Input Controller.</p>
<h3 id="zoominputtomonitor">ZoomInputToMonitor</h3>
<p>Moves the Input Controller so that it is right in front of the Monitor.</p>
        </main>

    </body>
</html>
